# HotSpot 虚拟机垃圾收集调优指南

## 文档基本信息

| 信息         | 描述          |
| ------------ | ------------- |
| 翻译人       | ShaoTeemo     |
| 校对         | ShaoTeemo     |
| JDK 版本     | 11            |
| 状态         | 初版完成。    |
| 初次完成时间 | 2023年5月17日 |
| 最后修改时间 | 2023年5月28日 |

> **本文档最终解释权归Oracle所有**



## 标题和版权信息

Java 平台标准版（JavaSE）

HotSpot虚拟机垃圾收集调优指南

Release 11	E95201-02	April 2022

本指南阐述 Java HotSpot 虚拟机 (Java HotSpot VM) （注：下文中称 JVM）中包含的垃圾收集方法，并帮助您确定最适合您需要的方法。

## 前言

*HotSpot虚拟机垃圾收集调优指南*描述了 Java 虚拟机 (Java HotSpot VM) 中包含的垃圾收集方法，帮助您确定最适合您需要的垃圾收集方式。

### 致读者

本文档适用于希望提高对Java虚拟机垃圾收集器理解的用户、应用程序开发人员和系统管理员。本文档进一步提供垃圾回收常见问题的分析和解决方案帮助，使应用程序满足用户的需求。

### 文档辅助功能

For information about Oracle's commitment to accessibility, visit the Oracle Accessibility Program website at http://www.oracle.com/pls/topic/lookup?ctx=acc&id=docacc.

**Access to Oracle Support**

Oracle customers that have purchased support have access to electronic support through My Oracle Support. For information, visit http://www.oracle.com/pls/topic/lookup?ctx=acc&id=info or visit http://www.oracle.com/pls/topic/lookup?ctx=acc&id=trs if you are hearing impaired.

### 相关文件

有关详细信息，请参阅以下文档：

- Garbage Collection: 自动动态内存管理算法。 Wiley，Chichester，1996 年 7 月。R. Lins 有一章介绍分布式垃圾收集。 Richard Jones、Anony Hosking 和 Elliot Moss。
- The Garbage Collection Handbook: 自动内存管理的艺术。 CRC 应用算法和数据结构。 Chapman & Hall，2012 年 1 月

### 文中约定

本文档中使用了以下文本约定：

| 约定       | 含义                                                         |
| :--------- | :----------------------------------------------------------- |
| **粗体**   | 粗体字表示与操作相关的图形用户界面元素，或在文本或词汇表中定义的术语。 |
| *斜体*     | 斜体表示书名、重点或您为其提供特定值的占位符变量。           |
| `等宽字体` | 等宽字体表示段落中的命令、URL、示例中的代码、出现在屏幕上的文本或您输入的文本。 |

## 一、垃圾回收调优简介

各种各样的应用程序，从桌面上的小程序到大型服务器上的 Web 服务，都使用Java SE。为了支持这种多样化的部署，Java虚拟机提供了多个垃圾收集器，每个垃圾收集器旨在满足不同的需求。Java SE 根据运行应用程序的计算机类别自动选择最合适的垃圾收集器。但是，此选择可能并非对每个应用程序都是最佳选择。具有严格性能目标或其他要求的用户、开发人员和管理员可能需要明确选择垃圾收集器并调整某些参数以达到所需的性能水平。本文档提供了有助于完成这些任务的信息。

<u>首先，垃圾收集器的一般特性和基本调优选项在垃圾收集暂停（stop-the-world）的上下文中进行了描述。</u>（译者注：垃圾回收有一个鲜明的特点会导致当前正在执行的任务暂停（stop-the-world ），此间隔一般会比较短）然后介绍了其他收集器的具体特征以及选择收集器时要考虑的因素。

**主题**

- 什么是垃圾收集器？
- 为什么选择合适的垃圾收集器很重要？
- 文档中支持的操作系统

### 什么是垃圾收集器？

垃圾收集器 (GC) 自动管理应用程序的动态内存分配请求。

垃圾收集器通过以下操作执行自动动态内存管理：

- 从操作系统分配获取内存并将内存返回给操作系统。
- 在应用程序请求时将该内存分配给应用程序。
- 确定应用程序仍在使用该内存的哪些部分。
- 回收未使用的内存以供应用程序重用。

Java虚拟机垃圾收集器采用各种技术来提高这些操作的效率：

- 将分代清理与老化结合使用，将他们的精力集中在堆中最有可能包含大量可回收内存的区域。
- 使用多线程并行操作，或者在后台与应用程序并发执行一些长时间运行的操作。
- 尝试通过压缩活动对象来恢复更大的连续空闲内存。

### 为什么选择合适的垃圾收集器很重要？

垃圾收集器的目的是解放开发人员手动动态内存管理中。开发人员不再需要关注内存分配与释放和密切关注分配的动态内存的生命周期。这完全消除了一些与内存管理相关的错误类别，但代价是一些额外的运行时开销。Java虚拟机提供了一系列垃圾回收算法供您选择。

为什么选择合适的垃圾收集器很重要？对于某些应用程序，答案是否定的。也就是说，应用程序可以在垃圾回收的情况下以适度频率的暂停执行（译者注：GC停顿时间）并在持续运行时良好。但是，对于大多数应用程序，尤其是那些具有大量数据（数 GB）、多线程和高事务率的应用程序，情况并非如此。

阿姆达尔定律（给定问题的并行加速受限于问题的顺序部分）意味着大多数工作负载无法完美并行化；程序执行的某些部分总是顺序执行因此不会从并行中受益。在 Java 平台中，目前有四种受支持的垃圾回收替代方案，除了串行 GC 之外，所有替代方案都将垃圾回收并行化以提高性能。尽可能降低垃圾回收时的开销非常重要。这可以在以下示例中看到。

图 1-1 中的图表模拟了一个理想的系统，该系统具有完美的可扩展性，但垃圾收集除外。红线是应用程序在单处理器系统上仅花费 1% 的时间进行垃圾回收。这意味着具有 32 个（核）处理器的系统的吞吐量损失超过 20%。洋红色线表明，对于 10% 的时间用于垃圾收集的应用程序（在单处理器应用程序中，垃圾收集的时间不算离谱），当扩展到 32 个（核）处理器时，超过 75% 的吞吐量会丢失。

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

​												***图 1-1 比较垃圾收集所花费时间的百分比***

该图表明，在小型系统上开发时可忽略不计的吞吐量问题可能会成为扩展到大型系统时的主要瓶颈。然而，在减少这种瓶颈方面的小改进可以产生很大的性能提升。对于一个足够大的系统，选择正确的垃圾收集器并在必要时对其进行调整是值得的。

串行收集器通常适用于大多数小型应用程序，特别是那些需要在现代处理器上使用高达大约100MB 的堆的应用程序。其他收集器有额外的开销或复杂性，这是针对性行为的代价。如果应用程序不需要备用收集器的特殊行为，请使用串行收集器。在具有大量内存和两个或更多处理器的机器上运行的大型、重线程应用程序使用串行收集器不是最佳选择。当应用程序在此类服务器级机器上运行时，默认情况下会选择Garbage-First（G1）收集器。

### 文档中支持的操作系统

本文档及其建议适用于所有 JDK 11 支持的系统配置，受特定配置中某些垃圾收集器的实际可用性限制。

## 二、人体工程学

*人体工程学是 Java 虚拟机 (JVM) 和垃圾回收启发式方法（例如基于行为的启发式方法）提高应用程序性能的过程。*

JVM 为垃圾收集器、堆大小和运行时编译器提供依赖于平台的默认选择。这些选择满足不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调整会动态优化堆的大小以满足应用程序的特定行为。

本节介绍这些默认选择和基于行为的调整。在使用后续部分中描述的更详细的控件之前，请使用这些默认值。

**主题**

- 垃圾收集器、堆和运行时编译器默认选择
- 基于行为的调整
  - 最大停顿时间
  - 吞吐量
  - 占用空间
- 调整策略

### 垃圾收集器、堆和运行时编译器默认选择

这些是重要的垃圾收集器、堆大小和运行时编译器默认选择：

- Garbage-First (G1)收集器
- 最大 GC 线程数受堆大小和可用 CPU 资源限制
- 初始堆大小为物理内存的 1/64
- 最大堆大小为物理内存的 1/4
- 分层编译器，同时使用 C1 和 C2

### 基于行为的调整

JVM垃圾收集器可以配置为优先满足两个指标之一：最大暂停时间和应用程序吞吐量。如果满足首选目标，收集器将尝试最大化另一个。自然地，这些指标并不总能实现：应用程序需要最小堆来保存至少所有实时数据，而其他配置可能会妨碍实现部分或全部预期指标。

#### 最大停顿时间

停顿时间是垃圾回收时暂停应用程序并回收不再使用的空间的持续时间。调整最大停顿时间的目的是限制最长的停顿时间。

垃圾回收器维护停顿的平均时间和该平均值的变化。平均值是从执行开始时获取的，但它是加权的，因此最近的暂停计数更重。如果平均值加上停顿时间的方差大于最大停顿时间指标，则垃圾回收器认为未达到期望值。

最大暂停时间调整是使用命令行选项 `-XX:MaxGCPauseMillis=<nnn>` 指定的。这被解释为对垃圾回收器的提示，即需要 `<nnn>` 毫秒或更短的停顿时间。垃圾回收器调整 Java 堆大小和其他与垃圾回收相关的参数，以试图使垃圾回收停顿时间短于 `<nnn>` 毫秒。最大停顿时间的默认值因垃圾回收器而异。这些调整可能会导致垃圾回收更频繁地发生，从而降低应用程序的整体吞吐量。但是，在某些情况下，无法达到所需的停顿时间期望值。

#### 吞吐量

吞吐量是根据收集垃圾所花费的时间来衡量的，在垃圾回收之外花费的时间就是*应用程序执行时间*。

吞吐量期望值由命令行选项 `-XX:GCTimeRatio=nnn` 指定。垃圾回收时间与应用程序时间之比为 1/ (1+nnn)。例如，-XX:GCTimeRatio=19 将指标设置为垃圾收集总时间的 1/20 或 5%。

垃圾收集花费的时间是所有垃圾回收导致停顿的总时间。如果没有达到吞吐量期望值，那么垃圾收集器的一种可能操作是增加堆的大小，以便应用程序在收集暂停之间花费的时间可以更长。

#### 占用空间

如果达到了吞吐量和最大停顿时间期望值，则垃圾收集器会减小堆的大小，直到无法满足其中一个指标（总是吞吐量期望值）。垃圾收集器可以使用的最小和最大堆大小可以分别使用 `-Xms<nnn>` 和 `-Xmx<mmm>` 设置最小和最大堆大小。

### 调整策略

堆增加或减小到支持所选吞吐量指标的大小。了解堆调整策略，例如选择最大堆大小和选择最大停顿时间指标。

不要为堆选择最大值，除非您知道您需要一个堆大小大于默认最大堆。选择一个足以满足您的应用程序的吞吐量指标。

应用程序行为的变化会导致堆增大或缩小。例如，如果应用程序开始以更高的速率进行分配，则堆会增长以维持相同的吞吐量。

如果堆增加到其最大大小并且未满足吞吐量指标，则最大堆大小对于吞吐量指标来说太小了。将最大堆大小设置为接近平台上总物理内存的值，但不会导致应用程序交换。再次执行应用程序。如果仍然没有达到吞吐量指标，那么应用程序时间的指标对于平台上的可用内存来说太高了。

如果可以达到吞吐量指标，但停顿时间太长，则选择最大停顿时间指标。选择最大停顿时间指标可能意味着无法满足您的吞吐量指标，因此请选择应用程序可以接受的折衷值。

当垃圾收集器试图满足相互竞争的指标时，堆的大小通常会波动。即使应用程序已达到稳定状态也是如此。实现吞吐量指标（可能需要更大的堆）的压力与最大停顿时间和最小占用空间（两者都可能需要较小的堆）的指标相互竞争。

## 三、垃圾收集器实现

Java SE 平台的优势之一是它使开发人员免于内存分配和垃圾收集的复杂性。

然而，当垃圾收集成为主要瓶颈时，了解实现的某些方面是很有用的。垃圾收集器对应用程序使用对象的方式做出假设，这些反映在可调参数中，可以调整这些参数以提高性能，而不会牺牲抽象的能力。

**主题**

- 分代垃圾收集
- 分代
- 性能注意事项
- 吞吐量和占用空间测量

### 分代垃圾收集

当运行程序中任何其他活动对象的任何引用不再能够访问该对象时，对象被认为是垃圾，它的内存可以被 VM 重用。

理论上，最直接的垃圾收集算法会在每次运行时迭代每个可到达的对象。任何剩余的对象都被视为垃圾。这种方法所花费的时间与活动对象的数量成正比，这对于维护大量活动数据的大型应用程序来说是令人望而却步的。

JVM 合并了许多不同的垃圾收集算法，这些算法都使用一种称为*分代收集的技术*。虽然一般垃圾收集每次都会检查堆中的每个活动对象，但分代收集利用大多数应用程序的几个凭经验观察到的属性来最大限度地减少回收未使用（垃圾）对象所需的工作。这些观察到的特性中最重要的是*弱分代假说*，它指出大多数对象只能存活很短的时间。

图 3-1 中的蓝色区域是对象生命周期的典型分布。x 轴显示以分配的字节为单位测量的对象生命周期。y 轴上的字节数是具有相应生命周期的对象中的总字节数。左边的尖峰表示在分配后不久就可以回收（换句话说，已经“死亡”）的对象。例如，迭代器（`iterator`）对象通常仅在单个循环期间有效。

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)

​													***图 3-1 对象生命周期的典型分布***

有些对象确实寿命更长，因此分布向右延伸。例如，通常有一些在初始化时分配的对象会一直存在到 VM 退出。在这两个极端之间的是在某些中间计算期间存在的对象，这里被视为初始峰值右侧的块。一些应用程序看起来分布非常不同，但数量惊人的多，都具有这种一般形状。通过专注大多数对象“早逝”这一事实，可以实现高效收集。

### 分代

为了针对这种情况进行优化，内存按代进行管理（内存池保存不同年龄的对象）。垃圾收集发生在每一代占满时。

绝大多数对象都分配在专用于新生成对象（新生代。 *young generation*）的池中，并且大多数对象都在那里回收。当新生代占满时，会引发一次小收集，只收集新生代（译注：*YoungGC*。Minor GC）；其他代的垃圾不会被回收。此类收集的成本首先与收集的活动对象数量成正比；很快就会收集充满待回收对象的新生代。通常，在每次要回收期间，新生代中的一部分幸存对象会被移动到老年代。最终，老年代被填满，必须被收集（译注：*OldGC*），导致一次集中收集，其中收集了整个堆（译注：*MajorGC* ，FullGC。即：一次MajorGC 至少伴随一次YoungGC）。MajorGC通常比Minor GC持续的时间长得多，因为涉及的对象数量要多得多。图 3-2 显示了串行垃圾收集器中代的默认排列：

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_001_armgnt_gn_new.png)

​											***图 3-2 Serial Collector 中的默认分代排列***

在启动时，JVM 会在地址空间中保留整个 Java 堆，但除非需要，否则不会为其分配任何物理内存。覆盖Java堆的整个地址空间在逻辑上分为年轻代和老年代。为对象内存保留的完整地址空间可以分为年轻代和老年代。

新生代由Eden和两个Survivor空间组成。大多数对象最初是在Eden中分配的。其中一个survivor空间随时为空，在垃圾回收时作为eden中存活对象的归宿，另一个survivor空间；在垃圾回收后，eden 和源 survivor 空间为空（译注：YoungGC发生后Eden和非空的survivor区对象会复制到另一个空的 survivor 区并置空Eden和源survivor区内容）。在下一次垃圾回收中，交换两个survivor空间的用途。最近填充的一个 survivor 空间是复制到另一个 survivor （译注：空 survivor ） 空间的活动对象的来源。对象以这种方式在 survivor 空间之间复制，直到它们被复制一定次数（译注：这个次数一般为YoungGC次数。默认为：15。）或 survivor 没有足够的空间。这些对象被复制到老年代。这个过程也称为老化。

### 性能注意事项

垃圾收集的主要衡量标准是吞吐量和延迟。

- *吞吐量*是长时间内未花费在垃圾收集上的总时间的百分比。吞吐量包括花费在分配上的时间（但通常不需要调整分配速度）。
- *延迟*是应用程序的响应能力。垃圾收集暂停会影响应用程序的响应能力。

用户对垃圾回收有不同的要求。例如，一些人认为 Web 服务器的正确指标是吞吐量，因为垃圾收集期间的停顿时间可能是可以容忍的，或者只是被网络延迟所掩盖。然而，在交互式图形程序中，即使是短暂的停顿也可能对用户体验产生负面影响。

一些用户对其他注意事项很敏感。*占用空间*是进程的工作集，以页面和缓存行为单位。在物理内存有限或进程较多的系统上，占用空间可能决定可伸缩性。*及时性*是对象死亡和内存可用之间的时间，这是分布式系统（包括远程方法调用 (RMI)）的重要考虑因素。

通常，为特定代选择大小是这些考虑因素之间的权衡。例如，一个非常大的年轻代可能会最大化吞吐量，但这样做会以占用空间、及时性和暂停时间为代价。可以通过以吞吐量为代价使用较小的年轻代来最小化年轻代停顿时间。一代的大小不会影响另一代的收集频率和停顿时间。

没有一种正确的方法来选择代的大小。最佳选择取决于应用程序使用内存的方式以及用户要求。因此，虚拟机对垃圾收集器的选择并不总是最佳的，并且可能会被命令行选项覆盖；请参阅《影响垃圾收集性能的因素》。

### 吞吐量和占用空间测量

吞吐量和占用空间最好使用特定于应用程序的指标来衡量。

例如，可以使用客户端负载生成器测试 Web 服务器的吞吐量，而可以使用 `pmap` 命令在 Solaris 操作系统上测量服务器的占用空间。但是，通过检查虚拟机本身的诊断输出可以很容易地估计由于垃圾收集而导致的停顿。

命令行选项 `-verbose:gc` 在每次收集时打印有关堆和垃圾收集的信息。这是一个例子：

```
[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M->57M(307M) (15,646s, 15,651s) 5,048ms
[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M->57M(307M) (16,146s, 16,162s) 16,565ms
[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M->31M(104M) (16,202s, 16,367s) 164,581ms
```

输出显示两个年轻代的垃圾收集，后面是一个完整的垃圾收集，该垃圾收集由应用程序调用 `System.gc()` 启动。这些行以时间戳开头，指示应用程序启动的时间。接下来是有关此行的日志级别 (info) 和标记 (gc) 的信息。随后是 GC 标识号。在这种情况下，有 3 个 GC，编号分别为 36、37 和 38。然后记录 GC 的类型和声明 GC 的原因。在此之后，会记录一些有关内存消耗的信息。该日志使用格式“在 GC 之前使用”->“在 GC 之后使用”（“堆大小”）。

在示例的第一行中，这是 239M->57M(307M)，这意味着在 GC 之前使用了 239 MB，GC 清除了大部分内存，但还有 57 MB 幸存下来。堆大小为 307 MB。请注意，在此示例中，FullGC 将堆从 307 MB 缩小到 104 MB。在内存使用信息之后，记录 GC 的开始和结束时间以及持续时间（结束 - 开始）。

`-verbose:gc` 命令是 `-Xlog:gc` 的别名。 -Xlog 是用于在 HotSpot JVM 中进行日志记录的常规日志记录配置选项。这是一个基于标签的系统，其中 gc 是标签之一。要获取有关 GC 正在执行的操作的更多信息，您可以配置日志记录以打印任何具有 gc 标记和任何其他标记的消息。命令行选项是 `-Xlog:gc*`。

这是使用 `-Xlog:gc*` 记录的一个 G1 年轻集合的示例：

```
[10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause) 
[10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation 
[10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms
[10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms 
[10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms 
[10.191s][info][gc,phases ] GC(36) Other: 0.2ms 
[10.191s][info][gc,heap ] GC(36) Eden regions: 286->0(276) 
[10.191s][info][gc,heap ] GC(36) Survivor regions: 15->26(38)
[10.191s][info][gc,heap ] GC(36) Old regions: 88->88 
[10.191s][info][gc,heap ] GC(36) Humongous regions: 3->1 
[10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K->8152K(1056768K)
[10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M->114M(508M) 13.075ms 
[10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s
```

> 注意：`-Xlog:gc*` 生成的输出格式在未来的版本中可能会发生变化。

## 四、影响垃圾收集性能的因素

影响垃圾回收性能的两个最重要的因素是可用内存总量和专用于新生代的堆的比例。

**主题**

- 总堆大小
  - 影响生成堆大小的选项
  - 堆大小的默认选项值
  - 通过最小化 Java 堆大小来节省动态占用空间
- 年轻代
  - 年轻代大小选项
  - Survivor区大小

### 总堆大小

影响垃圾收集性能的最重要因素是可用内存总量。因为收集发生在各代占满时，吞吐量与可用内存量成反比。

> 注意：以下关于堆的增长和收缩、堆布局和默认值的讨论以串行收集器为例。虽然其他收集器使用类似的机制，但此处提供的详细信息可能不适用于其他收集器。有关其他收集器的类似信息，请参阅相应的主题。

#### 影响生成堆大小的选项

许多选项会影响生成堆大小。图 4-1 说明了堆中已提交空间和虚拟空间之间的区别。虚拟机初始化时，为堆保留整个空间。可以使用 `-Xmx` 选项指定保留空间的大小。如果 `-Xms` 参数的值小于 `-Xmx` 参数的值，则并非所有保留的空间都会立即提交给虚拟机。未提交的空间在此图中标记为“虚拟”。堆的不同部分，即老年代和年轻代，可以根据需要增长到虚拟空间的极限。

一些参数是堆的一部分与另一部分的比率。例如，参数 `–XX:NewRatio` 表示老年代与年轻代的相对大小。

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_006_prm_gn_sz_new.png)

​														***图 4-1 堆选项***

#### 堆大小的默认选项值

默认情况下，虚拟机会在每次收集时增大或缩小堆，以尽量将每次收集时可用空间与活动对象的比例保持在特定范围内。

此目标范围由选项 `-XX:MinHeapFreeRatio=<minimum>` 和 `-XX:MaxHeapFreeRatio=<maximum>` 设置为百分比，并且总大小低于 `–Xms<min>` 高于 `–Xmx<max>` .64 位 Solaris 操作系统（SPARC 平台版）的默认选项如表 4-1 所示。

| 选项                   | 默认值     |
| :--------------------- | :--------- |
| `-XX:MinHeapFreeRatio` | 40         |
| `-XX:MaxHeapFreeRatio` | 70         |
| `-Xms`                 | 6656 KB    |
| `-Xmx`                 | calculated |

***表 4-1 64 位 Solaris 操作系统的默认选项***

使用这些选项，如果一代中可用空间的百分比低于 40%，则该代将扩展以保持 40% 的可用空间，直至达到该代允许的最大大小。类似地，如果可用空间超过 70%，则生成收缩，以便只有 70% 的空间可用，这取决于生成的最小大小。

如表 4-1 中所述，默认的最大堆大小是由 JVM 计算的值。Java SE 中用于并行收集器的计算现在用于所有垃圾收集器。计算的一部分是 64 位平台的最大堆大小的上限。请参阅《并行收集器默认堆大》。客户端 JVM 有类似的计算，这导致最大堆大小小于服务器 JVM。

以下是有关服务器应用程序堆大小的一般准则：

- 除非您遇到暂停问题，否则请尝试为虚拟机分配尽可能多的内存。默认大小通常太小。
- 将 `-Xms` 和 `-Xmx` 设置为相同的值可通过从虚拟机中删除最重要的大小调整决策来提高可预测性。但是，如果您做出了错误的选择，虚拟机将无法进行补偿。
- 通常，随着处理器数量的增加而增加内存，因为分配可以并行进行。

#### 通过最小化 Java 堆大小来节省动态占用空间

如果您需要最小化应用程序的动态内存占用量（执行期间消耗的最大 RAM），那么您可以通过最小化 Java 堆大小来实现。 Java SE Embedded 应用程序可能需要这个。

通过使用命令行选项 `-XX:MaxHeapFreeRatio` 和 `-XX:MinHeapFreeRatio` 降低选项 `-XX:MaxHeapFreeRatio`（默认值为 70%）和 `-XX:MinHeapFreeRatio`（默认值为 40%）的值来最小化 Java 堆大小。将 `-XX:MaxHeapFreeRatio` 降低至 10% 和 `-XX:MinHeapFreeRatio` 已显示可以成功减小堆大小而不会降低太多性能；但是，结果可能会因您的应用程序而有很大差异。为这些参数尝试不同的值，直到它们尽可能低，但仍保持可接受的性能。

此外，您可以指定 `-XX:-ShrinkHeapInSteps`，它会立即将 Java 堆减小到目标大小（由参数 `-XX:MaxHeapFreeRatio` 指定）。使用此设置可能会导致性能下降。默认情况下，Java 运行时会逐渐将 Java 堆减小到目标大小；这个过程需要多个垃圾收集周期。

### 年轻代

在总可用内存之后，影响垃圾收集性能的第二大影响因素是专用于年轻代的堆的比例。

年轻代越大，minor collections（译注：Minor GC、YoungGC） 发生的频率就越低。然而，对于有限的堆大小，较大的新生代意味着较小的老年代，这将增加major collections（译注：MajorGC、FullGC）的频率。最佳选择取决于应用程序分配的对象的生命周期分布。

#### 年轻代大小选项

默认的，新生代大小由选项 `-XX:NewRatio` 控制。

例如设置`-XX:NewRatio=3` 表示年轻代和老年代的比例为1:3。换句话说，eden 和 survivor 空间的组合大小将是总堆大小的四分之一。

选项 `-XX:NewSize` 和 `-XX:MaxNewSize` 从下限和上限限制年轻代的大小。将这些设置为相同的值可以修复年轻代，就像将 `-Xms` 和 `-Xmx` 设置为相同的值可以修复总堆大小一样。这对于以比 `-XX:NewRatio` 参数允许的整数倍更细粒度的调整年轻代很有用。

#### Survivor区大小

您可以使用选项 `-XX:SurvivorRatio` 来调整Survivor区的大小，但这通常对性能并不重要。

例如，`-XX:SurvivorRatio=6` 将Eden和Survivor区之间的比例设置为 1:6。换句话说，每个Survivor区将是Eden区大小的六分之一，因此是年轻代大小的八分之一（不是七分之一，因为有两个Survivor区）。

如果Survivor空间太小，那么复制集合会直接溢出到老年代。如果Survivor空间太大，那么它们将毫无用处地空着。在每次垃圾回收时，虚拟机都会选择一个阈值，即一个对象在旧之前可以被复制的次数。选择此阈值是为了让幸存者保持半满状态。可以使用日志配置`-Xlog:gc,age`可以用来显示这个阈值和新生代对象的年龄。它对于观察应用程序的生命周期分布也很有用。

表 4-2 提供了 64 位 Solaris 的默认值。

| 选项                | 默认值      |
| :------------------ | :---------- |
| `-XX:NewRatio`      | 2           |
| `-XX:NewSize`       | 1310 MB     |
| `-XX:MaxNewSize`    | not limited |
| `-XX:SurvivorRatio` | 8           |

​									***表 4-2 Survivor空间大小调整的默认选项值***

新生代的最大大小是根据总堆的最大大小和 `-XX:NewRatio` 参数的值计算得出的。`-XX:MaxNewSize` 参数的“不受限制”默认值意味着计算值不受 `-XX:MaxNewSize` 的限制，除非在命令行上指定了 `-XX:MaxNewSize` 的值。

以下是服务器应用程序的一般准则：

- 首先确定您可以为虚拟机提供的最大堆大小。然后，将你的性能指标与年轻代的大小进行对比，以找到最佳设置。
  - 请注意，最大堆大小应始终小于机器上安装的内存量，以避免过多的页面错误和抖动。
- 如果总堆大小是固定的，那么增加新生代的大小就需要减少老年代的大小。保持老年代足够大以容纳应用程序在任何给定时间使用的所有实时数据，外加一定量的松弛空间（10% 到 20% 或更多）。
- 受制于之前声明的对老年代的约束：
  - 给年轻代足够的内存。
  - 随着处理器数量的增加，年轻代的大小也会增加，因为分配可以并行化。

## 五、可用的收集器

到目前为止的讨论都是关于串行收集器的。 Java HotSpot VM 包括三种不同类型的收集器，每种都有不同的性能特征。

**主题**

- 串行收集器
- 并行收集器
- 并发收集器
- 垃圾收集器的选择

### 串行收集器

串行收集器使用单个线程来执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。

它最适合单处理器机器，因为它不能利用多处理器硬件，尽管它在多处理器上对于具有小数据集（最多大约 100 MB）的应用程序很有用。串行收集器在某些硬件和操作系统配置上默认选择，或者可以使用选项 `-XX:+UseSerialGC` 显式启用。

### 并行收集器

并行收集器也称为*吞吐量收集器*，它是一种类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个用于加速垃圾收集的线程。

并行收集器适用于在多处理器或多线程硬件上运行的具有中型到大型数据集的应用程序。您可以使用 `-XX:+UseParallelGC` 选项启用它。

并行压缩是一种使并行收集器能够并行执行MajorGC的功能。如果没有并行压缩，主要的收集是使用单个线程执行的，这会限制可伸缩性。如果指定了选项 `-XX:+UseParallelGC`，则默认启用并行压缩。您也可以使用 `-XX:-UseParallelOldGC` 选项禁用它。

### 并发收集器

Concurrent Mark Sweep (CMS) 收集器和 Garbage-First (G1) 垃圾收集器是两个主要的并发收集器。大多数并发收集器与应用程序并发执行一些复杂的工作。

- G1 垃圾收集器：这种服务器风格的收集器适用于具有大量内存的多处理器机器。它很有可能满足垃圾收集停顿时间指标，同时实现高吞吐量。

  在某些硬件和操作系统配置中默认选择 G1，或者可以使用 `-XX:+UseG1GC` 显式启用。

- CMS 收集器：此收集器适用于更喜欢较短的垃圾收集停顿时间并且能够与垃圾收集共享处理器资源的应用程序。

  使用选项 `-XX:+UseConcMarkSweepGC` 启用 CMS 收集器

从 JDK 9 开始，CMS 收集器已被弃用。

### Z 垃圾收集器

Z 垃圾收集器 (ZGC) 是一种可扩展的低延迟垃圾收集器。 ZGC 并发执行所有复杂的工作，而不会停止应用程序线程的执行。

ZGC 适用于需要低延迟（少于 10 毫秒停顿）和（或）使用非常大的堆（数 TB）的应用程序。您可以使用 `-XX:+UseZGC` 选项启用它。

从 JDK 11 开始，ZGC 作为一项实验性功能提供。

### 垃圾收集器的选择

除非你的应用程序有相当严格的停顿时间要求，否则首先运行你的应用程序并允许 VM 选择一个收集器。

如有必要，调整堆大小以提高性能。如果性能仍未达到您的目标，请使用以下指南作为收集器选择的起点：

- 如果应用程序有一个小数据集（最多约 100 MB），则选择带有选项 `-XX:+UseSerialGC` 的串行收集器。
- 如果应用程序将在单个处理器上运行并且没有停顿时间要求，则选择带有选项 `-XX:+UseSerialGC` 的串行收集器。
- 如果峰值应用程序 (a) 性能是第一优先级并且 (b) 没有停顿时间要求或一秒或更长时间的停顿是可以接受的，那么让 VM 选择收集器或使用 `-XX:+UseParallelGC` 选择并行收集器.
- 如果响应时间比整体吞吐量更重要，并且垃圾收集停顿必须保持在大约一秒以内，则选择具有 `-XX:+UseG1GC` 或 `-XX:+UseConcMarkSweepGC` 的并发收集器。
- 如果响应时间是一个高优先级，和（或）你正在使用一个非常大的堆，那么选择一个带有 `-XX:UseZGC` 的完全并发收集器。

这些指南仅提供了收集器选择的起点，因为性能取决于堆的大小、应用程序维护的实时数据量以及可用处理器的数量和速度。

如果推荐的收集器没有达到预期的性能，那么首先尝试调整堆和生成大小以满足预期的目标。如果性能仍然不足，则尝试不同的收集器：使用并发收集器来减少暂停时间，使用并行收集器来增加多处理器硬件上的整体吞吐量。

## 六、并行收集器

并行收集器（这里也称为吞吐量收集器）是一种类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个用于加速垃圾收集的线程。

并行收集器通过命令行选项 `-XX:+UseParallelGC` 启用。默认情况下，使用此选项，MinorGC和MajorGC并行运行以进一步减少垃圾收集开销。

**主题**

- 并行收集器垃圾收集器线程数
- 并行收集器中的代排列
- 并行收集器中的人体工程学
  - 指定并行收集器行为的选项
  - 并行收集器目标的优先级
  - 并行收集器生成大小调整
  - 并行收集器默认堆大小
    - 并行收集器初始和最大堆大小的规范
- 并行收集时间过长和 OutOfMemoryError
- 并行收集器监测

### 并行收集器垃圾收集器线程数

在具有 <N> 个硬件线程（其中 <N> 大于 8）的机器上，并行收集器使用 <N> 的固定分数作为垃圾收集器线程数。

对于较大的 <N> 值，分数约为 5/8。当 <N> 的值低于 8 时，使用的数字是 <N>。在选定的平台上，该比例降至 5/16。垃圾收集器线程的具体数量可以通过命令行选项进行调整（稍后介绍）。在具有一个处理器的主机上，由于并行执行所需的开销（例如，同步），并行收集器的性能可能不如串行收集器。然而，当运行具有中型到大型堆的应用程序时，它通常在具有两个处理器的计算机上略胜于串行收集器，并且在有两个以上处理器可用时通常比串行收集器表现更好。

可以使用命令行选项 `-XX:ParallelGCThreads=<N>` 控制垃圾收集器线程的数量。如果您使用命令行选项调整堆，那么并行收集器获得良好性能所需的堆大小与串行收集器所需的堆大小相同。但是，启用并行收集器应该可以缩短收集停顿时间。因为多个垃圾收集器线程正在参与MinorGC，所以在收集期间从年轻代提升到老年代可能会产生一些碎片。MajorGC中涉及的每个垃圾回收线程都会保留一部分老年代用于提升，将可用空间划分为这些“提升缓冲区”会导致碎片效应。减少垃圾收集器线程的数量并增加老年代的大小将减少这种碎片效应。

### 并行收集器中的代排列

并行收集器中代的排列是不同的。

这种排列如图 6-1 所示：

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_002_armgnt_gn_pl_new.png)

​										***图 6-1 并行收集器中的生成排列***

### 并行收集器中的人体工程学

当使用 `-XX:+UseParallelGC` 选择并行收集器时，它会启用一种自动调整方法，允许您指定行为而不是生成大小和其他低级别调整细节。

#### 指定并行收集器行为的选项

您可以指定最大垃圾收集停顿时间、吞吐量和占用空间（堆大小）。

- 最大垃圾收集停顿时间：最大停顿时间目标是使用命令行选项 `-XX:MaxGCPauseMillis=<N>` 指定的。这被解释为需要 <N> 毫秒或更短的停顿时间的提示；默认情况下，没有最大停顿时间指标。如果指定了停顿时间指标，则会调整堆大小和其他与垃圾收集相关的参数，以尝试使垃圾收集停顿时间短于指定值；然而，可能并不总能达到所需的停顿时间指标。这些调整可能会导致垃圾收集器降低应用程序的整体吞吐量。

- 吞吐量：吞吐量目标是根据垃圾收集所花费的时间与垃圾收集之外所花费的时间（称为*应用程序时间*）来衡量的。指标由命令行选项 `-XX:GCTimeRatio=<N>` 指定，它将垃圾收集时间与应用程序时间的比率设置为 1 / (1 + <N>)。

  例如，`-XX:GCTimeRatio=19` 将目标设置为垃圾收集总时间的 1/20 或 5%。默认值为 99，目标是 1% 的时间用于垃圾回收。

- 占用空间：最大堆占用空间使用选项 `-Xmx<N>` 指定。此外，收集器有一个隐含的目标，即在满足其他目标的情况下最小化堆的大小。

#### 并行收集器目标的优先级

目标是最大停顿时间指标、吞吐量指标和最小占用空间指标，指标按以下顺序处理：

首先满足最大停顿时间指标。只有在达到指标之后，吞吐量指标才会得到解决。同样，只有在满足前两个指标后，才会考虑占用空间指标。

#### 并行收集器生成大小调整

收集器保存的平均停顿时间等统计信息在每次收集结束时更新。

然后进行确定是否已达到指标的测试，并对生成的大小进行任何必要的调整。例外情况是显式垃圾收集，例如，调用 `System.gc()` 在保留统计信息和调整生成大小方面会被忽略。

增加和缩小代的大小是通过增量来完成的，增量是代大小的固定百分比，以便代逐步增加或减少到其所需的大小。增长和收缩以不同的速度进行。默认情况下，代以 20% 的增量增长，以 5% 的增量收缩。增长百分比由新生代的命令行选项 `-XX:YoungGenerationSizeIncrement=<Y>` 和老年代的 `-XX:TenuredGenerationSizeIncrement=<T>` 控制。代缩小的百分比由命令行标志 `-XX:AdaptiveSizeDecrementScaleFactor=<D>` 调整。如果增长增量为X%，则收缩减量为X/D%。

如果收集器决定在启动时增长代，则会在增量中添加一个补充百分比。此补充百分比随垃圾收集次数递减，无长远效果。补充百分比的目的是提高启动性能。收缩百分比没有补充。

如果未达到最大停顿时间目标，则一次只会缩小一代的大小。如果两代的停顿时间都在目标之上，那么停顿时间较大的那一代的规模首先缩小。

如果没有达到吞吐量目标，那么两代的大小都会增加。每一个都与其各自对总垃圾收集时间的贡献成比例地增加。例如，如果新生代的垃圾收集时间是总收集时间的 25%，如果新生代的完整增量为 20%，那么新生代将增加 5%。

#### 并行收集器默认堆大小

除非在命令行中指定初始和最大堆大小，否则它们是根据机器上的内存量计算的。默认的最大堆大小是物理内存的1/4，而初始堆大小是物理内存的 1/64。分配给新生代的最大空间量是总堆大小的1/3。

##### 并行收集器初始和最大堆大小的规范

您可以使用选项 `-Xms`（初始堆大小）和 `-Xmx`（最大堆大小）指定初始和最大堆大小。

如果您知道您的应用程序需要多少堆才能正常工作，那么您可以将 `-Xms` 和 `-Xmx` 设置为相同的值。如果您不知道，那么 JVM 将首先使用初始堆大小，然后增长 Java 堆，直到它在堆使用和性能之间找到平衡。

其他参数和选项会影响这些默认值。要验证您的默认值，请使用 `-XX:+PrintFlagsFinal` 选项并在输出中查找 `-XX:MaxHeapSize`。例如，在 Linux 或 Solaris 上，您可以运行以下命令：

```shell
java -XX:+PrintFlagsFinal <GC options> -version | grep MaxHeapSize
```

### 并行收集时间过长和 OutOfMemoryError

如果在垃圾收集 (GC) 上花费的时间过多，并行收集器将抛出 OutOfMemoryError。

如果超过 98% 的总时间花在了垃圾收集上，而只有不到 2% 的堆被回收，则会抛出 OutOfMemoryError。此功能旨在防止应用程序长时间运行而由于堆太小而进展甚微或根本没有进展。如有必要，可以通过将选项 `-XX:-UseGCOverheadLimit` 添加到命令行来禁用此功能。

### 并行收集器监测

并行收集器的详细垃圾收集器输出与串行收集器的输出基本相同。

## 七、并发收集器

并发收集器与应用程序同时执行部分工作，因此得名。 Java HotSpot VM 包括两个主要并发的收集器：

- Concurrent Mark Sweep (CMS) 收集器：此收集器适用于更喜欢较短的垃圾收集暂停并且能够与垃圾收集共享处理器资源的应用程序。
- Garbage-First (G1) 垃圾收集器：这种服务器风格的收集器适用于具有大量内存的多处理器机器。它以高概率满足垃圾收集停顿时间指标，同时实现高吞吐量。

### 并发收集器的开销

大多数并发收集器以处理器资源（否则应用程序可用）换取更短的主要收集停顿时间。

最明显的开销是在收集的并发部分使用一个或多个处理器。在 N 个处理器系统上，集合的并发部分使用 K/N 个可用处理器，其中 1 <= K <= ceiling{N/4}。除了在并发阶段使用处理器之外，还会产生额外的开销来启用并发。因此，虽然并发收集器的垃圾收集停顿通常要短得多，但应用程序吞吐量也往往略低于其他收集器。

在具有多个处理核心的机器上，处理器在垃圾回收的并发部分可用于应用程序线程，因此并发垃圾收集器线程不会暂停应用程序。这通常会导致更短的暂停时间，但同样更少的处理器资源可供应用程序使用，并且应该预料到速度会有所下降，尤其是在应用程序最大限度地使用所有处理内核的情况下。随着 N 的增加，并发垃圾收集对处理器资源的减少变得更小，并发收集带来的好处增加。请参阅《并发模式故障》，其中讨论了此类扩展的潜在限制。

因为在并发阶段至少有一个处理器用于垃圾收集，所以并发收集器通常不会在单处理器（单核）机器上提供任何好处。

## 八、Concurrent Mark Sweep (CMS)收集器

Concurrent Mark Sweep (CMS：并发标记清除收集器) 收集器专为喜欢较短的垃圾收集停顿并且能够在应用程序运行时与垃圾收集器共享处理器资源的应用程序而设计。

通常，具有相对较大的长期数据集（大型老年代）并在具有两个或更多处理器的机器上运行的应用程序往往会受益于此收集器的使用。CMS 收集器通过命令行选项 `-XX:+UseConcMarkSweepGC` 启用。

CMS 收集器已弃用。强烈建议改为使用Garbage-First（G1）收集器。

**主题**

- CMS 收集器性能和结构
- 并发模式失败
- GC 时间过长和 OutOfMemoryError
- CMS 收集器和浮动垃圾
- CMS 收集器停顿
- CMS 收集器并发阶段
- 开始并发收集周期
- 调度暂停
- CMS 收集器监测

### CMS 收集器性能和结构

与其他可用的收集器类似，CMS 收集器是分代的；因此，MinorGC 和 MajorGC 都会发生。CMS 收集器尝试通过使用单独的垃圾收集器线程来跟踪与应用程序线程的执行并发的可访问对象，从而减少主要收集引起的暂停时间。

在每个 MajorGC 周期中，CMS 收集器在收集开始时暂停所有应用程序线程一小段时间，然后在收集中间再次暂停。第二次停顿往往是两次停顿中较长的一次。多个线程在两次暂停期间执行收集工作。一个或多个垃圾收集器线程执行收集的剩余部分（包括活动对象的大部分跟踪和无法访问的对象的清除）。MinorGC 可以与正在进行的 MajorGC 周期交错，并以类似于并行收集器的方式完成（特别是，应用程序线程在 MinorGC 期间停止）。

### 并发模式故障

CMS 收集器使用一个或多个与应用程序线程同时运行的垃圾收集器线程，目的是在老年代变满之前完成收集。

如前所述，在正常操作中，CMS 收集器在应用程序线程仍在运行时完成其大部分跟踪和清理工作，因此应用程序线程只会看到短暂的停顿。但是，如果 CMS 收集器无法在老年代填满之前完成回收无法访问的对象，或者如果老年代中的可用空闲空间块无法满足分配，则应用程序将暂停并将所有应用程序线程都停止直至完成垃圾回收。无法并发完成收集称为并发模式故障，表明需要调整 CMS 收集器参数。如果并发收集被显式垃圾收集 `(System.gc())` 中断或为诊断工具提供信息所需的垃圾收集中断，则会报告并发模式中断。

### GC 时间过长和 OutOfMemoryError

如果在垃圾收集上花费了太多时间，CMS 收集器会抛出一个 `OutOfMemoryError`：如果超过 98% 的总时间花在了垃圾收集上，并且只有不到 2% 的堆被回收，那么就会抛出一个`OutOfMemoryError`。

此功能旨在防止应用程序长时间运行而由于堆太小而进展甚微或根本没有进展。如有必要，可以通过将选项 `-XX:-UseGCOverheadLimit` 添加到命令行来禁用此功能。

该策略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入 98% 的时间限制。换句话说，只有在应用程序停止时执行的收集才会计入过长的 GC 时间。此类收集通常是由于并发模式故障或显式收集请求（例如，调用 `System.gc()`）。

### CMS 收集器和浮动垃圾

与 Java HotSpot VM 中的所有其他收集器一样，CMS 收集器是一个跟踪收集器，它至少识别堆中的所有可达对象（译注：即可达性分析）。

Richard Jones 和 Rafael D. Lins 在他们的出版的《*Garbage Collection: Algorithms for Automated Dynamic Memory*》中，它是一个增量更新收集器。因为应用程序线程和垃圾收集器线程在 MajorGC 期间同时运行，垃圾收集器线程跟踪的对象可能随后在收集过程结束时变得不可访问。这种尚未被回收的不可达对象称为*浮动垃圾*。浮动垃圾的数量取决于并发收集周期的持续时间和应用程序引用更新（也称为*突变*）的频率。此外，因为年轻代和老年代是独立收集的，所以每个都充当另一个根的来源。作为一个粗略的指南，尝试将老年代的大小增加 20% 以解决浮动垃圾问题。一个并发收集周期结束时堆中的浮动垃圾将在下一个收集周期中收集。

### CMS 收集器停顿

CMS 收集器在并发收集周期中暂停应用程序两次。第一次是将可从根直接访问的对象（例如，来自应用程序线程堆栈和寄存器的对象引用、静态对象等）和来自堆中其他地方（例如，新生代）的对象标记为活动对象。

第一次暂停被称为*初始标记停顿（initial mark pause）*。第二次发生在并发跟踪阶段结束时，它会查找由于应用程序线程在 CMS 收集器完成跟踪对象后更新对象中的引用而被并发跟踪遗漏的对象。第二次停顿称为*重标记停顿（remark pause）*。

### CMS 收集器并发阶段

可达对象的并发跟踪发生在初始标记停顿和重新标记停顿之间。

在此并发跟踪阶段期间，一个或多个并发垃圾收集器线程可能正在使用本来可用于应用程序的处理器资源。因此，计算密集型应用程序在此阶段和其他并发阶段可能会看到应用程序吞吐量相应下降，即使应用程序线程没有暂停也是如此。标记暂停后，并发清除阶段收集标识为无法访问的对象。收集周期完成后，CMS 收集器等待，几乎不消耗任何计算资源，直到下一个 MajorGC 周期开始。

### 开始并发收集周期

使用串行收集器，每当老年代变满时就会发生 MajorGC，并且在收集完成前停止所有应用程序线程。相比之下，CMS 收集器中并发收集的开始必须定时，以便收集可以在老年代占满之前完成；否则，由于并发模式故障，应用程序将观察到更长的停顿时间。有几种方法可以开始并发收集。

根据最近的历史记录，CMS 收集器维护对老年代耗尽之前剩余时间的估计以及并发收集周期所需的时间。使用这些动态估计，并发收集周期开始，目的是在老年代空间耗尽之前完成收集周期。为安全起见，对这些估计进行了填充，因为并发模式故障的代价可能非常高。

如果老年代的占用率超过初始占用率（老年代的百分比），并发收集也会开始。此初始占用阈值的默认值约为 92%，但该值可能会因版本而异。可以使用命令行选项 `-XX:CMSInitiatingOccupancyFraction=<N>` 手动调整此值，其中 <N> 是老年代大小的整数百分比（0 到 100）。

### 调度暂停

新生代回收和老年代回收的停顿是独立发生的。

它们不重叠，但可能会快速连续发生，因此一次收集的暂停，紧接着另一次收集的暂停，可能看起来是一个单一的、更长的暂停。为了避免这种情况，CMS 收集器尝试将标记暂停大致安排在上一个和下一个年轻代暂停之间的中间。初始标记停顿（initial mark pause）目前没有做这个调度，初始标记停顿（initial mark pause） 通常比重标记停顿（remark pause） 短很多。

### CMS 收集器监测

以下是带有选项 `-Xlog:gc` 的 CMS 收集器的输出：

```log
[121,834s][info][gc] GC(657) Pause Initial Mark 191M->191M(485M) (121,831s, 121,834s) 3,433ms
[121,835s][info][gc] GC(657) Concurrent Mark (121,835s)
[121,889s][info][gc] GC(657) Concurrent Mark (121,835s, 121,889s) 54,330ms
[121,889s][info][gc] GC(657) Concurrent Preclean (121,889s)
[121,892s][info][gc] GC(657) Concurrent Preclean (121,889s, 121,892s) 2,781ms
[121,892s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s)
[121,949s][info][gc] GC(658) Pause Young (Allocation Failure) 324M->199M(485M) (121,929s, 121,949s) 19,705ms
[122,068s][info][gc] GC(659) Pause Young (Allocation Failure) 333M->200M(485M) (122,043s, 122,068s) 24,892ms
[122,075s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s, 122,075s) 182,989ms
[122,087s][info][gc] GC(657) Pause Remark 209M->209M(485M) (122,076s, 122,087s) 11,373ms
[122,087s][info][gc] GC(657) Concurrent Sweep (122,087s)
[122,193s][info][gc] GC(660) Pause Young (Allocation Failure) 301M->165M(485M) (122,181s, 122,193s) 12,151ms
[122,254s][info][gc] GC(657) Concurrent Sweep (122,087s, 122,254s) 166,758ms
[122,254s][info][gc] GC(657) Concurrent Reset (122,254s)
[122,255s][info][gc] GC(657) Concurrent Reset (122,254s, 122,255s) 0,952ms
[122,297s][info][gc] GC(661) Pause Young (Allocation Failure) 259M->128M(485M) (122,291s, 122,297s) 5,797ms
```

> 注意：CMS 集合（GC ID 657）的输出散布在MinorGC（GC ID 658、659 和 660）的输出中；通常在并发收集周期中会发生许多MinorGC。Pause Initial Mark 表示并发收集周期的开始。以“Concurrent”开头的行表示并发阶段的开始和结束。Pause Remark 是最后的暂停。之前没有讨论的是预清洗阶段。 Precleaning 表示可以同时完成的工作，为 remark 阶段做准备。最后阶段由 Concurrent Reset 指示，并为下一个并发收集做准备。

初始标记停顿通常比 MinorGC 停顿时间短。如 CMS 收集器输出示例所示，并发阶段（并发标记、并发预清理和并发清除）通常比 MinorGC 停顿持续的时间长得多。但是请注意，应用程序不会在这些并发阶段暂停。标记停顿的长短通常与 MinorGC 相当。重新标记停顿受某些应用程序特性（例如，高对象修改率会增加此停顿）和自上次 MinorGC 以来的时间（例如，年轻代中的对象更多可能会增加此停顿时间）的影响。

## 九、Garbage-First 垃圾收集器

本节介绍Garbage-First (G1) 垃圾收集器 (GC)。

**主题**

- Garbage-First 垃圾收集器简介
- 启用 G1
- 基本概念
  - 堆布局
  - 垃圾回收周期
- G1 内部机制
  - 确定Initiating Heap Occupancy
  - 标记
  - 非常紧张的堆情况下的行为
  - 大对象
  - Young-Only 阶段大小调整
  - Space-Reclamation 阶段生成大小
- G1 GC 的人体工程学默认设置
- 与其他收集器的比较

### Garbage-First 垃圾收集器简介

Garbage-First (G1) 垃圾收集器针对具有<u>大量内存的多处理器机器</u>。它试图以高概率满足垃圾收集停顿时间目标，同时实现高吞吐量且几乎不需要配置。G1 旨在使用当前目标应用程序和环境提供延迟和吞吐量之间的最佳平衡，其功能包括：

- 堆大小高达 10 GB 或更大，其中超过 50% 的 Java 堆被实时数据占用。
- 对象分配和提升的速率可能会随时间发生显着变化。
- 堆中有大量碎片。
- 可预测的停顿时间目标不超过几百毫秒，避免长时间的垃圾收集停顿。

G1 取代了并发标记-清除 (CMS) 收集器。它也是默认收集器。

G1 收集器实现高性能并尝试通过以下部分中描述的几种方式来满足暂停时间目标。

### 启用 G1

Garbage-First 垃圾收集器是默认收集器，因此通常您不必执行任何其他操作。您可以通过在命令行上提供 `-XX:+UseG1GC` 来显式启用它。

### 基本概念

G1 是一个分代的、增量的、并行的、**并发的**、stop-the-world （暂时中止） 和迁移垃圾收集器，它监视每个暂停中的暂停时间目标。与其他收集器类似，G1 将堆分成（虚拟）年轻代和老年代。内存回收工作集中在最有效的年轻代，偶尔在老年代进行内存回收。

某些操作总是在暂停中执行以提高吞吐量。在应用程序停止时其他操作（例如*全局标记*等全堆操作）会花费更多的时间与应用程序并行并发执行。为了使空间回收时暂停时间变短，G1 逐步并行地执行空间回收。G1 通过跟踪有关先前应用程序行为和垃圾收集停顿的信息来构建相关成本的模型来实现可预测性。它使用此信息来确定在暂停期间垃圾回收完成量。例如，G1 首先回收效率最高的空间区域（即大部分充满垃圾的区域，因此得名）。

G1 主要通过使用迁移来回收空间：在选定的内存区域内找到要收集的活动对象并复制到新的内存区域，且在此过程中对数据压缩。迁移完成后，活动对象原始占用的空间将重新用于应用程序分配。

G1 收集器不是实时收集器。它试图在更长的时间内以高概率满足设定的暂停时间期望值，但对于给定的停顿并不总是绝对确定的。

#### 堆布局

G1 将堆划分为一组大小相同的堆区域，每个区域都是连续的虚拟内存范围，如图 9-1 所示。区域是内存分配和内存回收的单位。在任何给定时间，这些区域中的每一个都可以是空的（浅灰色），或者分配给特定的代，年轻代或年老代。随着内存请求的到来，内存管理器分发空闲区域。内存管理器将它们分配给代，然后将它们作为可用空间返回给应用程序，它可以分配自己的空闲空间。

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_004_grbg_frst_hp.png)

​														***图 9-1 G1 垃圾收集器堆布局***

年轻代包含Eden区域（红色）和Survivor区域（红色带有“S”）。这些区域提供与其他收集器中相应的连续空间相同的功能，不同之处在于在 G1 中这些区域通常以非连续模式布局在内存中。旧区域（浅蓝色）组成老年代。对于跨越多个区域的对象（译注：泛指大对象），老年代区域可能非常庞大（带“H”的浅蓝色）。

应用程序总是分配到年轻代，即Eden区域，直接分配为属于老年代的巨大对象除外。

G1 垃圾收集暂停可以回收整个年轻代中的空间，以及任何收集暂停时的任何额外的老年代区域。在暂停期间，G1 将此区域集中的对象复制到堆中的一个或多个不同区域。对象的目标区域取决于该对象的源区域：整个年轻代被复制到survivor或老年代，对象从老年代复制到其他不同的老年代使其老化。

#### 垃圾回收周期

在高层次上，G1 收集器在两个阶段之间交替。仅年轻阶段包含垃圾收集，这些垃圾收集逐渐用老年代中的对象填充当前可用的内存。空间回收阶段 G1 除了处理年轻代之外，还逐步回收老年代的空间。然后循环以仅年轻的阶段重新开始。

图 9-2 给出了这个循环的概览，并举例说明了可能发生的垃圾收集暂停序列：

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_001_grbgcltncyl.png)

​																***图 9-2 垃圾回收周期概览***

下面的列表详细描述了 G1 垃圾收集周期的阶段、它们的停顿和阶段之间的转换：

1. Young-only 阶段：这个阶段从一些普通的的年轻集合开始，这些集合将对象提升到老年代。当老年代占用率达到某个阈值（Initiating Heap Occupancy threshold）时，young-only 阶段和空间回收阶段之间的转换开始。此时，G1 安排了一个 Concurrent Start YoungGC，而不是一个普通的 YoungGC。
   - Concurrent Start ：这种类型的收集除了执行正常的 YoungGC 之外还启动标记过程。并发标记确定老年代区域中所有当前可访问的（活动的）对象，以便为接下来的 space-reclamation 保留。虽然收集标记还没有完全完成，但可能会发生正常的 YoungGC 。标记以两个特殊的 stop-the-world 暂停结束：Remark 和 Cleanup。
   - Remark ：此停顿完成标记本身，执行全局引用处理和类卸载，回收完全空的区域并清理内部数据结构。在 Remark 和 Cleanup 之间 G1 计算信息以便稍后能够同时回收选定老年代区域中的可用空间，这将在 Cleanup 暂停中完成。
   - Cleanup：这个暂停决定了space-reclamation是否会真正跟进。如果随后是space-reclamation，则 young-only 阶段将以单个 Prepare Mixed  YoungGC完成。
2. Space-reclamation 阶段：这个阶段由多个Mixed collections组成，除了新生代区域，还迁移老年代区域集合的活动对象。当 G1 确定迁移更多老年代区域不会产生足够的可用空间时，空间回收阶段结束。

空间回收后，收集周期从另一个 young-only 阶段重新开始。作为备份，如果应用程序在收集活动信息时内存不足，G1 会像其他收集器一样执行 in-place stop-the-world 的全堆压缩（Full GC）。

### G1 内部机制

本节介绍Garbage-First (G1)收集器的一些重要细节。

#### 确定Initiating Heap Occupancy

*Initiating Heap Occupancy Percent (IHOP)* 是触发初始标记收集的阈值，它被定义为老年代大小的百分比。

默认情况下，G1 通过观察标记需要多长时间以及在标记周期中老年代通常分配多少内存来自动确定最佳 IHOP。此功能称为*自适应 IHOP*。如果此功能处于开启状态，那么选项 `-XX:InitiatingHeapOccupancyPercent` 会将初始值确定为当前年老代大小的百分比，只是没有足够的观察结果来很好地预测 Initiating Heap Occupancy 阈值。可以使用选项`-XX:-G1UseAdaptiveIHOP` 关闭 G1 的这种行为。在这种情况下，`-XX:InitiatingHeapOccupancyPercent` 的值始终决定该阈值。

在内部，自适应 IHOP 尝试设置 Initiating Heap Occupancy，以便当老年代占用率处于当前最大老年代大小减去 `-XX:G1HeapReservePercent` 的值作为额外缓冲区时，空间回收阶段的第一次混合垃圾收集开始.

#### 标记

G1 标记使用一种称为 `Snapshot-At-The-Beginning (SATB)` 的算法。它在初始标记停顿时获取堆的虚拟快照，此时所有在标记开始时处于活动状态的对象在标记的其余部分都被认为是活动的。这意味着出于空间回收（space-reclamation）的目的，在标记过程中变为非存活（无法访问）的对象仍然被认为是活的（有一些例外）。与其他 GC 相比，这可能会导致一些额外的内存被错误地保留。但是，SATB 可能会在 Remark 暂停期间提供更好的延迟。在该标记期间被认为过于保守的活动对象将在下一次标记期间被回收。有关标记问题的更多信息，请参阅《G1 GC调优》。

#### 常紧张的堆情况下的行为

当应用程序保持活动状态的内存如此之多以至于迁移找不到足够的空间进行复制时，迁移失败就会发生。迁移失败意味着 G1 尝试通过将任何已移动的对象保留在新位置来完成当前垃圾收集，而不复制任何尚未移动的对象，仅调整对象之间的引用。迁移失败可能会产生一些额外的开销，但通常应该与其他 YoungGC 一样快。在这次迁移失败的垃圾收集之后，G1 将照常恢复应用程序，无需任何其他措施。G1 假设迁移失败发生在接近垃圾收集结束的时候；也就是说，大多数对象已经被移动，并且有足够的空间来继续运行应用程序，直到标记完成和空间回收开始。

如果这个假设不成立，那么 G1 最终会安排一次 Full GC。这种类型的收集执行整个堆的就地压缩。这可能非常慢。

有关内存不足信号之前分配失败或 Full GC 问题的更多信息，请参阅《G1 GC调优》。

#### 大对象

大对象是大于或等于半个区域大小的对象。当前区域大小根据人体工程学确定，如 《G1 GC 的人体工程学默认值》部分所述，除非使用 `-XX:G1HeapRegionSize` 选项进行设置。

这些大对象有时会以特殊方式处理：

- 每个巨大的对象都被分配为老年代中的一系列连续区域。对象本身的起点始终位于该序列中第一个区域的起点。在回收整个对象之前，序列最后一个区域中的任何剩余空间都将丢失分配。
- 通常，巨大的对象只能在清理暂停期间标记结束时回收，或者如果它们变得无法访问，则在 Full GC 期间回收。但是，对于原始类型数组（例如 bool、各种整数和浮点值）的巨大对象有特殊规定。如果在任何类型的垃圾收集暂停期间没有被对象引用，G1 会尝试回收巨大的对象。默认情况下启用此功能，但您可以使用选项 `-XX:G1EagerReclaimHumongousObjects` 禁用它。
- 超大对象的分配可能会导致垃圾收集暂停过早发生。 G1 在每个巨大的对象分配时检查 Initiating Heap Occupancy 阈值，如果当前占用超过该阈值，则可能会立即强制执行初始标记YoungGC。
- 巨大的对象永远不会移动，即使在 Full GC 期间也是如此。这可能会导致 Full GC 过早、变慢或出现意外的内存不足情况，并且由于区域空间的碎片化而留下大量可用空间。

#### Young-Only 阶段大小调整

在Young-Only阶段，要收集的区域集仅由年轻代区域组成。G1 总是在下一个突变阶段的正常YoungGC 结束时调整年轻代的大小。这样，G1 可以根据对实际停顿时间的长期观察，使用 `-XX:MaxGCPauseTimeMillis` 和 `-XX:PauseTimeIntervalMillis` 设置的暂停时间指标。它考虑了类似规模的年轻代迁移需要多长时间。这包括诸如在收集期间必须复制多少对象以及这些对象之间的相互关联程度等信息。

如果没有其他约束，那么 G1 自适应地调整新生代大小在 `-XX:G1NewSizePercent` 和 `-XX:G1MaxNewSizePercent` 确定的值之间以满足停顿时间。有关如何修复长时间停顿的更多信息，请参阅《G1 GC调优》。

#### Space-Reclamation 阶段生成大小

在 Space-Reclamation 阶段，G1 尝试在一次垃圾回收暂停中最大化老年代回收的空间量。新生代的大小设置为允许的最小值，通常由 `-XX:G1NewSizePercent` 确定，并且添加任何老年代区域以回收空间，直到 G1 确定添加更多区域将超过停顿时间目标。在特定的垃圾回收停顿中，G1按照回收效率从高到低、剩余可用时间的顺序添加老年代区域，得到最终的回收集。

每次垃圾收集要占用的老年代区域数量的下限是要收集的潜在候选老年代区域（收集候选区域）的数量，除以由`-XX:G1MixedGCCountTarget` 确定的空间回收阶段的长度。收集候选区域是阶段开始时占用率低于 `-XX:G1MixedGCLiveThresholdPercent` 的所有老年代区域。

当收集候选区域中剩余可回收空间量小于`-XX:G1HeapWastePercent`设置的百分比时，该阶段结束。

有关 G1 将使用多少老年代区域以及如何避免长时间混合收集停顿的更多信息，请参阅《》。

### G1 GC 的人体工程学默认设置

本主题概述了特定于 G1 的最重要的参数及其默认值。他们粗略地概述了使用 G1 时的预期行为和资源使用情况，没有任何其他选项。

| 选项及默认值                                                 | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `-XX:MaxGCPauseMillis=200`                                   | 最大停顿时间。                                               |
| `-XX:GCPauseTimeInterval`=*<ergo>*                           | 最大停顿时间间隔。默认情况下 G1 不设置任何值，允许 G1 在极端情况下背靠背执行垃圾收集。 |
| `-XX:ParallelGCThreads`=*<ergo>*                             | 垃圾收集暂停期间用于并行工作的最大线程数。这是从运行 VM 的计算机的可用线程数得出的，方法如下：如果进程可用的 CPU 线程数小于或等于 8，则使用可用的 CPU 线程。否则将大于的线程数的八分之五添加到最终线程数。<br/>在每次暂停开始时，使用的最大线程数进一步受到最大总堆大小的限制：G1 不会为每个 `-XX:HeapSizePerGCThread` Java 堆容量使用超过一个线程。 |
| `-XX:ConcGCThreads`=*<ergo>*                                 | 用于并发工作的最大线程数。默认情况下，这个值是 `-XX:ParallelGCThreads` 除以 4。 |
| `-XX:+G1UseAdaptiveIHOP`<br />`-XX:InitiatingHeapOccupancyPercent=45` | 用于控制启动堆占用的默认值表示该值的自适应确定已打开，并且对于前几个收集周期，G1 将使用老年代 45% 的占用作为标记开始阈值。 |
| `-XX:G1HeapRegionSize=<ergo> `                               | 基于初始和最大堆大小的堆区域大小。因此该堆包含大约 2048 个堆区域。堆区域的大小可以从 1 到 32 MB 不等，并且必须是 2 的幂。 |
| `-XX:G1NewSizePercent=5``-XX:G1MaxNewSizePercent=60`         | 年轻代的总大小，在这两个值之间变化，作为当前使用的 Java 堆的百分比。 |
| `-XX:G1HeapWastePercent=5`                                   | 集合候选中允许的未回收空间百分比。如果收集区域候选中的可用空间低于该值，G1 将停止空间回收阶段。 |
| `-XX:G1MixedGCCountTarget=8`                                 | 集合中space-reclamation阶段的预期长度。                      |
| `-XX:G1MixedGCLiveThresholdPercent=85`                       | 在此space-reclamation阶段不会收集活动对象占用率高于此百分比的老年代区域。 |

​													***表 9-1 人体工程学默认值 G1 GC***

> 注：<ergo>表示实际值是根据环境符合人体工程学确定的。

### 与其他收集器的比较

这是 G1 和其他收集器之间主要区别的总结：

- Parallel GC 只能作为一个整体来压缩和回收老年代的空间。 G1 逐渐将这项工作分布到多个更短的集合中。这会以潜在的吞吐量为代价大大缩短停顿时间。
- 与 CMS 类似，G1 并发执行部分老年代内存回收。但是，CMS 无法对老年代堆进行碎片整理，最终会遇到长时间的 Full GC。
- G1 可能比其他收集器有更高的开销，由于其并发性质而影响吞吐量。

由于其工作方式，G1 有一些独特的机制来提高垃圾收集效率：

- G1 可以在任何收集过程中回收一些完全空的、大面积的老年代。这可以避免许多不必要的垃圾回收，无需太多努力即可释放大量空间。
- G1 可以选择性地尝试同时删除 Java 堆上的重复字符串。

从老年代回收空的大对象总是启用的。您可以使用选项 `-XX:-G1EagerReclaimHumongousObjects` 禁用此功能。默认情况下禁用字符串重复数据删除。您可以使用选项 `-XX:+G1EnableStringDeduplication` 启用它。

## 十、G1 GC调优

本节介绍如何调整 G1 GC 行为，以满足您的要求。

**主题**

- G1 的一般建议
- 从其他收集器迁移到 G1
- 提高 G1 性能
  - 观察完整的垃圾收集
  - 大对象碎片
  - 调整延迟
    - 异常系统或实时使用
    - 映射对象处理时间过长
    - Young-Only 阶段中的 Young-Only 收集花费的时间太长
    - 混合收集花费的时间太长
    - 高更新 RS 和扫描 RS 时间
  - 调整吞吐量
  - 调整堆大小
  - 可调默认值

### G1 的一般建议

一般建议使用 G1 的默认设置，最终给它一个不同的停顿时间数值，并在需要时使用 `-Xmx` 设置最大 Java 堆大小。

G1 默认值的平衡不同于其他任何一个收集器。 G1 在默认配置中的目标既不是最大吞吐量也不是最低延迟，而是在高吞吐量时提供相对较小、统一的停顿。但是，G1 在堆中增量回收空间的机制和停顿时间控制会在应用程序线程和空间回收效率方面产生一些开销。

如果您更喜欢高吞吐量，请使用 `-XX:MaxGCPauseMillis` 放宽停顿时间目标或提供更大的堆。如果延迟是主要要求，则修改停顿时间值。避免使用 `-Xmn`、`-XX:NewRatio` 等选项将年轻代大小限制为特定值，因为年轻代大小是 G1 满足停顿时间的主要手段。将年轻代大小设置为单个值会覆盖并实际上禁用停顿时间控制。

### 从其他收集器迁移到 G1

通常，当从其他收集器（尤其是 CMS 收集器）移至 G1 时，首先删除所有影响垃圾回收的选项，并仅使用 `-Xmx` 和可选的 `-Xms` 设置停顿时间值和总体堆大小。

许多对其他收集器以某种特定方式响应有用的选项要么根本没有效果，要么甚至降低吞吐量和满足暂停时间目标的可能性。一个例子可能是设置年轻代大小，完全阻止 G1 调整年轻代大小以满足暂停时间目标。

### 提高 G1 性能

G1 旨在提供良好的整体性能，而无需指定额外的选项。但是，在某些情况下，它们的默认启发式算法或默认配置会提供次优结果。本节提供了一些有关诊断和改进这些情况的指南。本指南仅描述了在给定应用程序的情况下，G1 提供的在选定指标中提高垃圾收集器性能的可能性。根据具体情况，应用程序级优化可能比尝试调整 VM 以更好地执行更有效，例如，通过使用寿命较短的对象来避免一些问题情况。

出于诊断目的，G1 提供全面的日志记录。一个好的开始是使用 `-Xlog:gc*=debug` 选项，然后在必要时优化输出。该日志提供有关垃圾收集活动停顿期间和停顿之外的详细概览。这包括收集的类型和在暂停的特定阶段花费的时间明细。

以下小节探讨了一些常见的性能问题。

#### 观察完整的垃圾收集

一次全堆垃圾回收（Full GC）通常非常耗时。老年代堆占用过高导致的Full GC可以通过日志中的Pause Full（Allocation Failure）字样来检测。Full GC 之前通常是遇到由 `to-space exhausted` 标记指示的迁移失败的垃圾收集。

发生Full GC的原因是应用程序分配了太多的对象，无法足够快地回收。通常，并发标记无法及时完成以启动内存回收阶段。遇到 Full GC 的可能性会因分配许多巨大的对象而变得复杂。由于这些对象在 G1 中的分配方式，它们可能会占用比预期更多的内存。

目标应该是确保并发标记按时完成。这可以通过降低老年代的分配率，或者给并发标记更多的时间来完成。

G1 为您提供了几个选项来更好地处理这种情况：

- 您可以使用 `gc+heap=info` 日志记录确定 Java 堆上巨大对象占用的区域数。`“Humongous regions: X->Y”`行中的 `Y` 为您提供被巨大对象占据的区域数量。如果这个数字与旧区域的数量相比很高，最好的选择是尝试减少这个对象的数量。您可以通过使用 `-XX:G1HeapRegionSize` 选项增加区域大小来实现此目的。当前选择的堆区域大小打印在日志的开头。
- 增加 Java 堆的大小。这通常会增加标记必须完成的时间量。
- 通过显式设置 `-XX:ConcGCThreads` 来增加并发标记线程的数量。
- 强制 G1 更早开始标记。 G1 根据早期的应用程序行为自动确定初始堆占用百分比 (IHOP) 阈值。如果应用程序行为发生变化，这些预测可能是错误的。有两种选择： 通过修改 `-XX:G1ReservePercent` 来增加自适应 IHOP 计算中使用的缓冲区，从而降低何时开始空间回收的目标占用率；或者，通过使用 `-XX:-G1UseAdaptiveIHOP` 和 `-XX:InitiatingHeapOccupancyPercent` 手动设置来禁用 IHOP 的自适应计算。

除完整 GC 的分配失败之外的其他原因通常表示应用程序或某些外部工具导致Full GC。如果原因是 `System.gc()`，并且没有办法修改应用程序源，可以使用 `-XX:+ExplicitGCInvokesConcurrent` 来减轻 Full GC 的影响，或者通过设置 `-XX:+DisableExplicitGC` 让 VM 完全忽略它们.外部工具可能仍然会强制执行 Full GC；只有不请求它们才能删除它们。

#### 大对象碎片

由于需要为它们找到一组连续的区域，因此可能会在所有 Java 堆内存耗尽之前发生 Full GC。在这种情况下，可能的选项是通过使用选项 `-XX:G1HeapRegionSize` 来增加堆区域大小以减少超大对象的数量，或者增加堆的大小。在极端情况下，可能没有足够的连续空间可供 G1 分配对象，即使可用内存另有指示也是如此。如果 Full GC 无法回收足够的连续空间，这将导致 VM 退出。因此，除了如前所述减少庞大的对象分配量或增加堆外，别无选择。

#### 调整延迟

本节讨论在常见延迟问题（即停顿时间过长）的情况下改进 G1 行为的提示。

##### 异常系统或实时使用

对于每次垃圾收集暂停，`gc+cpu=info` 日志输出包含一行信息，其中包含来自操作系统的信息，其中包含有关暂停时间所花时间的详细分类。此类输出的示例是 `User=0.19s Sys=0.00s Real=0.01s`。

用户时间是在 VM 代码中花费的时间，系统时间是在操作系统中花费的时间，实时是暂停期间经过的绝对时间量。如果系统时间相对较长，则通常是环境原因。

高系统时间的常见已知问题是：

- VM 从操作系统内存中分配或归还内存可能会导致不必要的延迟。通过使用选项 `-Xms` 和 `-Xmx` 将最小和最大堆大小设置为相同的值来避免延迟，并使用 `-XX:+AlwaysPreTouch` 预接触所有内存以将此工作移至 VM 启动阶段。
- 特别是在 Linux 中，通过*透明大页面 (THP)*（Transparent Huge Pages） 功能将小页面合并为普通大页面（Huge pages）往往会停止随机进程，而不仅仅是在暂停期间。由于 VM 分配和维护大量内存，因此 VM 将成为长时间停滞的进程的风险比平常更高。有关如何禁用透明大页面功能的信息，请参阅操作系统的文档。
- 由于一些后台任务间歇性地占用了写入日志的硬盘的所有 I/O 带宽，因此写入日志输出可能会停止一段时间。考虑为您的日志或一些其他存储使用单独的磁盘，例如内存支持的文件系统以避免这种情况。

另一种需要注意的情况是实时比其他情况的总和大很多，这可能表明虚拟机在一台可能过载的机器上没有获得足够的 CPU 时间。

##### 映射对象处理时间过长

有关映射对象处理所用时间的信息显示在`Reference Processing`阶段。在`Reference Processing`阶段，G1根据特定类型Reference Object的要求更新Reference Objects的映射。默认情况下，G1 尝试使用以下参数并行化引用处理的子阶段：对于每个 `-XX:ReferencesPerThread` 引用对象启动一个线程，以 `-XX:ParallelGCThreads` 中的值为界。可以通过将 `-XX:ReferencesPerThread` 设置为 0 来禁用此参数并以默认使用所有可用线程，或者通过 `-XX:-ParallelRefProcEnabled` 完全禁用并行化。

##### Young-Only 阶段中的 Young-Only 收集花费的时间太长

正常的新生代一般来说，任何新生代收集所花费的时间大致与新生代的大小成正比，或者更具体地说，是集中收集需要复制的活动对象的数量。如果 `Evacuate Collection Set` 阶段花费的时间太长，特别是对象复制子阶段，请减少 `-XX:G1NewSizePercent`参数值。此操作减少了年轻代的最小大小，允许可能更短的暂停。

如果应用程序，尤其是在收集中幸存的对象数量突然发生变化，则可能会出现与新生代大小有关的另一个问题。这可能会导致垃圾回收停顿时间激增。使用参数 `-XX:G1MaxNewSizePercent` 降低新生代的最大大小可能会有用。此操作限制了新生代的最大大小，从而限制了暂停期间需要处理的对象数量。

##### 混合收集花费的时间太长

混合收集用于回收老年代的空间。混合收集的集合包含年轻代和老年代区域。您可以通过启用 `gc+ergo+cset=trace` 日志输出来获取有关年轻代或老年代区域迁移多少时间对停顿时间有贡献的信息。分别查看新生代区域和老年代区域预测的年轻区域时间和预测的老区域时间。

如果预测的年轻区域时间太长，请参阅《Young-Only 阶段中的 Young-Only 收集花费的时间太长》中的选项。否则，为了减少老年代区域对停顿时间，G1 提供了三个选项：

- 通过增加 `-XX:G1MixedGCCountTarget`，将老年代区域回收分布到更多的垃圾收集中。
- 通过使用 `-XX:G1MixedGCLiveThresholdPercent` 不将它们放入候选收集集合中，避免收集需要大量时间收集的区域。在许多情况下，高度占用的区域需要花费大量时间来收集。
- 尽早停止老年代空间回收，这样 G1 就不会收集那么多高度占用的区域。在这种情况下，增加`-XX:G1HeapWastePercent`。

请注意，最后两个选项减少了当前空间回收阶段可以回收空间的收集集合候选区域的数量。这可能意味着 G1 可能无法在老年代回收足够的空间来持续运行。但是，稍后的空间回收阶段可能能够对它们进行垃圾回收。

##### 高更新 RS 和扫描 RS 时间

为了使 G1 能够迁移单个老年代区域，G1 跟踪跨区域引用的位置，即从一个区域指向另一个区域的引用。指向给定区域的跨区域引用集称为该区域的*记忆集（remembered set，又称：RS）*（译注：即跨代引用，在G1中，又叫跨Region引用）。移动区域的内容时必须更新记忆集。区域记忆集的维护大部分是并发的。出于性能目的，当应用程序在两个对象之间安装新的跨区域引用时，G1 不会立即更新区域的记忆集。 记忆集更新请求被延迟和批处理以提高效率。

G1 需要完整的记忆集来进行垃圾收集，因此垃圾收集的更新 RS 阶段会处理任何未完成的记忆集更新请求。Scan RS 阶段在记忆集中搜索对象引用，移动区域内容，然后将这些对象引用更新到新位置。根据应用程序的不同，这两个阶段可能会花费大量时间。

使用选项 `-XX:G1HeapRegionSize` 调整堆区域的大小会影响跨区域引用的数量以及记忆集的大小。处理区域的记忆集可能是垃圾收集工作的重要部分，因此这对可实现的最大停顿时间有直接影响。较大的区域往往具有较少的跨区域引用，因此处理它们所花费的相对工作量会减少，但与此同时，较大的区域可能意味着每个区域需要迁移更多活动对象，从而增加其他阶段的时间。

G1 尝试安排记忆集更新的并发处理，以便更新 RS 阶段大约占用允许的最大暂停时间的 `-XX:G1RSetUpdatingPauseTimePercent` 百分比。通过减小这个值，G1 通常会同时执行更多的记忆集更新工作。

虚假的高 Update RS 时间与分配大对象的应用程序相结合可能是由试图通过批处理减少并发记忆集更新工作的优化引起的。如果创建此类批处理的应用程序恰好发生在垃圾回收之前，那么垃圾回收必须在暂停时更新 RS 时间部分处理所有这些工作。使用 `-XX:-ReduceInitialCardMarks` 禁用此行为并可能避免这些情况。

扫描 RS （Scan RS） 时间还取决于 G1 为保持较低的记忆集存储大小而执行的压缩量。记忆集在内存中存储的越紧凑，在垃圾收集期间检索存储值所需的时间就越多。G1 自动执行此压缩，称为记忆集粗化，同时根据该区域记忆集的当前大小更新记忆集。特别是在最高压缩级别，检索实际数据可能会非常慢。选项 `-XX:G1SummarizeRSetStatsPeriod` 结合 `gc+remset=trace`日志级别显示是否发生这种粗化。如果是这样，那么在 *Before GC Summary* 部分的 `Did <X> coarsenings` 行中的 `X` 显示一个高值。

可以显著增加 `-XX:G1RSetRegionEntries` 选项以减少这些粗化的数量。避免在生产环境中使用此详细的记忆集日志记录，因为收集此数据可能会花费大量时间。

#### 调整吞吐量

G1 的默认策略试图在吞吐量和延迟之间保持平衡；然而，有些情况下需要更高的吞吐量。除了如前几节所述减少整体暂停时间外，还可以降低暂停频率。主要思想是通过使用 `-XX:MaxGCPauseMillis` 来增加最大暂停时间。代大小启发会自动调整年轻代的大小，这直接决定了停顿的频率。如果这没有导致预期的行为，特别是在空间回收阶段，使用 `-XX:G1NewSizePercent` 增加最小年轻代大小将强制 G1 这样做。

在某些情况下，`-XX:G1MaxNewSizePercent`（允许的最大年轻代大小）可能会通过限制年轻代大小来限制吞吐量。这可以通过查看 `gc+heap=info` 日志记录输出的区域摘要来诊断。在这种情况下，Eden 区域和 Survivor 区域的组合百分比接近区域总数的 `-XX:G1MaxNewSizePercent` 百分比。在这种情况下考虑增加`-XX:G1MaxNewSizePercent`。

增加吞吐量的另一个选择是尝试减少并发工作量，特别是并发记忆集更新通常需要大量 CPU 资源。增加 `-XX:G1RSetUpdatingPauseTimePercent` 将工作从并发操作移至垃圾收集暂停时。在最坏的情况下，可以通过设置 `-XX:-G1UseAdaptiveConcRefinement -XX:G1ConcRefinementGreenZone=2G -XX:G1ConcRefinementThreads=0` 来禁用并发记忆集更新。这主要是禁用此机制并将所有记住的集合更新工作移至下一个垃圾收集暂停时。

通过使用 `-XX:+UseLargePages` 启用大页面也可以提高吞吐量。有关如何设置大页面的信息，请参阅您的操作系统文档。

您可以通过禁用它来最小化调整堆大小的工作；将选项 `-Xms` 和 `-Xmx` 设置为相同的值。此外，您可以使用 `-XX:+AlwaysPreTouch` 将操作系统工作转移到 VM 启动时使用物理内存支持虚拟内存。为了使停顿时间更加一致，这两种措施都可能是特别理想的。

#### 调整堆大小

与其他收集器一样，G1 旨在调整堆的大小，以便垃圾收集所花费的时间低于 `-XX:GCTimeRatio` 选项确定的比率。调整此选项使 G1 满足您的要求。

#### 可调默认值

本节介绍默认值以及有关本主题中介绍的命令行选项的一些附加信息。

| 选项及默认值                                                 | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `-XX:+G1UseAdaptiveConcRefinement``-XX:G1ConcRefinementGreenZone=`*<ergo>*`-XX:G1ConcRefinementYellowZone=`*<ergo>*`-XX:G1ConcRefinementRedZone=`*<ergo>*`-XX:G1ConcRefinementThreads=`*<ergo>* | 并发记忆集更新（细化）使用这些选项来控制并发细化线程的工作分配。G1 为这些选项选择符合人体工程学的值，以便 `-XX:G1RSetUpdatingPauseTimePercent` 时间花费在垃圾收集暂停中以处理任何剩余工作，并根据需要自适应地调整它们。请谨慎更改，因为这可能会导致极长的暂停。 |
| `-XX:+ReduceInitialCardMarks`                                | 这批并发记忆集更新（优化）工作用于初始对象分配。             |
| `-XX:+ParallelRefProcEnabled``-XX:ReferencesPerThread=1000`  | `-XX:ReferencesPerThread` 确定并行化程度：对于每 *N* 个引用对象，一个线程将参与引用处理的子阶段，受 `-XX:ParallelGCThreads` 限制。0 表示将始终使用 `-XX:ParallelGCThreads` 值指示的最大线程数。<br />这决定了 `java.lang.Ref.*` 实例的处理是否应该由多个线程并行完成。 |
| `-XX:G1RSetUpdatingPauseTimePercent=10`                      | 这决定了 G1 在更新 RS 阶段更新任何剩余的记忆集应该花费的总垃圾收集时间的百分比。G1 使用此设置控制并发记忆集更新的数量。 |
| `-XX:G1SummarizeRSetStatsPeriod=0`                           | 这是许多 GC 中 G1 生成记忆集摘要报告的时期。将此设置为0以禁用。生成记忆集摘要报告是一项代价高昂的操作，因此只有在必要时才应使用它，并且具有合理的高价值。使用 `gc+remset=trace` 打印任何输出。 |
| `-XX:GCTimeRatio=12`                                         | 这是应该花在垃圾收集上而不是应用程序上的目标时间比的除数。用于确定在增加堆之前可用于垃圾回收的目标时间分数的实际公式是 `1 / (1 + GCTimeRatio)`。此默认值导致目标将大约 8% 的时间花在垃圾收集上。 |

> 注：<ergo>表示实际值是根据环境根据人体工程学确定的。

## 十一、Z 垃圾收集器

Z 垃圾收集器 (ZGC) 是一种可扩展的低延迟垃圾收集器。ZGC 并发执行所有复杂的工作，不会停止应用程序线程的执行超过 10 毫秒，这使得它适用于需要低延迟和（或）使用非常大的堆（数 TB）的应用程序。

Z 垃圾收集器作为一项实验性功能提供，并通过命令行选项 `-XX:+UnlockExperimentalVMOptions -XX:+UseZGC` 启用。

### 设置堆大小

ZGC 最重要的调整选项是设置最大堆大小 (`-Xmx`)。由于 ZGC 是并发收集器，因此必须选择最大堆大小，以便 ：1、 堆可以容纳应用程序的活动集。 2、堆中有足够的空间允许在 GC 运行时为分配提供服务。需要多少空间在很大程度上取决于应用程序的分配率和 `live-set` 大小。一般来说，给ZGC的内存越多越好。但与此同时，浪费内存是不可取的，所以这一切都是为了在内存使用和 GC 需要运行的频率之间找到平衡。

### 设置GC并发线程数

大家可能想要查看的第二个调优选项是设置并发 GC 线程数 (`-XX:ConcGCThreads`)。ZGC 有启发式自动选择这个数字。这种启发式方法通常效果很好，但根据应用程序的特性，可能需要对其进行调整。这个选项本质上决定了应该给 GC 多少 CPU 时间。给它太多，GC 将从应用程序中窃取太多 CPU 时间。给得太少，应用程序分配垃圾的速度可能比 GC 收集垃圾的速度快。

## 十二、其他注意事项

本节介绍影响垃圾收集的其他情况。

**主题**

- 最终化（Finalization）和弱引用、软引用和虚引用
- 显式垃圾收集
- 软引用
- 类元数据

### 最终化和弱引用、软引用和虚引用

一些应用程序通过使用最终化和弱引用、软引用或虚引用与垃圾回收进行交互。

但是，不鼓励使用最终化。它可能导致安全性、性能和可靠性方面的问题。例如，依靠最终化来关闭文件描述符会使外部资源（描述符）依赖于垃圾收集的及时性。

> 注意：最终化在 JDK 9 中已被弃用。

#### 最终化

一个类可以声明一个终结器（finalizer） —— 方法 `protected void finalize()`——它的主体释放任何底层资源。GC会调度一个不可达对象的finalizer，在GC回收对象内存之前调用。

当没有从 GC 根到对象的路径时（译注：可达性分析），对象变得不可访问，因此有资格进行垃圾收集。GC 根包括来自活动线程的引用和内部 JVM 引用；它们是将对象保存在内存中的引用。

请参阅在《 [Monitoring the Objects Pending Finalization](https://docs.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/gctuning&id=JSTGD-GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B) in Java Platform, Standard Edition Troubleshooting Guide》中监视挂起的对象以确定可终结的对象是否正在您的系统中构建。此外，您可以使用以下工具之一：

- JDK 任务控制：
  1. 在**JVM Browser**中，右键单击您的 JVM 并选择 **Start JMX Console**。
  2. 在**MBean Browser**的**MBean Tree**中，展开**java.lang**并选择**Memory**。
  3. 在**MBean Features**中，属性**ObjectPendingFinalizationCount**是等待完成的对象的近似数量。
- `jcmd` tool：
  - 运行以下命令以打印有关 Java 最终化队列的信息；值 <pid> 是您的 JVM 的 PID：
    `jcmd <pid> GC.finalizer_info`

#### 最终化迁移

为避最终化，请使用以下技术之一：

- try-with-Resources 语句
- Cleaner API

##### try-with-Resources 语句

try-with-resources 语句是声明一个或多个资源的 try 语句。资源是一个对象，在程序使用完它后必须关闭。ry-with-resources 语句可确保在代码块末尾关闭每个资源，即使出现一个或多个异常也是如此。有关详细信息，请参阅《[The Try-with-resources Statement](https://dev.java/learn/catching-and-handling-exceptions/#anchor_6)》

##### Cleaner API

如果您预见到应用程序中资源的生命周期将超出 try-with-resources 语句的范围，那么您可以改用 Cleaner API。Cleaner API 允许程序为对象注册一个清理操作，该操作在对象变得不可访问后运行一段时间。

Cleaners 使您能够避免终结器的许多缺点：

- 更安全：Cleaners 必须显式注册一个对象。此外，清理操作无法访问它，因此对象复活是不可能的。
- 更好的性能：您可以更好地控制何时注册清理操作，这意味着清理操作永远不会处理未初始化或部分初始化的对象。您还可以取消对象的清理操作。
- 更可靠：您可以控制哪些线程运行清理操作。

但是，与终结器一样，垃圾收集器会安排清理操作，因此它们可能会遭受无限延迟。因此，不要在需要及时释放资源的情况下使用Cleaner API。

下面是一个cleaner的简单示例。它执行以下操作：

1. 定义一个cleaner动作类State，它初始化清洁动作并定义清洁动作本身（通过重写State::run()方法）。

2. 创建 `Cleaner` 的实例。

3. 使用此 `Cleaner` 实例，注册对象 `myObject1` 和清理操作（State 的实例）。

4. 为确保垃圾收集器调度清洁器并在示例结束前执行清洁操作 `State::run()`，示例：

   a. 将 `myObject1` 设置为 `null` 以确保它是幻象不可访问的。参见《参考对象类型》 。

   b. 在循环中调用 `System.gc()` 以触发垃圾收集清理。

```java
import java.lang.ref.Cleaner;

public class CleanerExample {
    
    // This Cleaner is shared by all CleanerExample instances
    private static final Cleaner CLEANER = Cleaner.create();
    private final State state;

    public CleanerExample(String id) {
        state = new State(id);
        CLEANER.register(this, state);
    }

    // Cleaning action class for CleanerExample
    private static class State implements Runnable {
        final private String id;

        private State(String id) {
            this.id = id;
            System.out.println("Created cleaning action for " + this.id);
        }

        @Override
        public void run() {
            System.out.println("Cleaner garbage collected " + this.id);
        }
    }

    public static void main(String[] args) {
        CleanerExample myObject1 = new CleanerExample("myObject1");

        // Make myObject1 unreachable
        myObject1 = null;

        System.out.println("-- Give the GC a chance to schedule the Cleaner --");
        for (int i = 0; i < 100; i++) {
            
            // Calling System.gc() in a loop is usually sufficient to trigger
            // cleanup in a small program like this.
            System.gc();
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {}
        }
        System.out.println("-- Finished --");
    }
}
```

​														***图 12-1 CleanerExample***

此示例打印以下内容：

```
Created cleaning action for myObject1
-- Give the GC a chance to schedule the Cleaner --
Cleaner garbage collected myObject1
-- Finished --
```

如果您要为生产环境实施清理器，请考虑以下事项：

- 清理操作类（本例中的 `State`）应该是一个私有的实现细节。特别是，不应在 `main(String[])` 方法中使用它。因此，只要可行，您的清洁操作类应该是不可变的。一个新对象应该处理创建自己的清洁动作类并在其构造函数中向清洁器注册自己。
- 类通常需要访问清洁器操作类中的对象。最简单的方法是让对象保存对清洁器操作类的引用。
- 应该共享`Cleaner` 的实例。在此示例中，`CleanerExample` 的所有实例都应共享一个静态的 `Cleaner` 实例。

有关实现清洁器的更多信息，请参阅 [Cleaner](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ref/Cleaner.html) 类的 JavaDoc API 文档。

#### 参考对象类型

共有三种引用对象类型：`SoftReference`、`WeakReference` 和 `PhantomReference`。每个引用对象类型对应于不同级别的可达性。以下是可达性的不同级别，从最强到最弱，它们反映了对象的生命周期：

- 如果某个线程可以在不遍历任何引用对象的情况下访问某个对象，则该对象是强可达的。新创建的对象可以被创建它的线程强访问。
- 如果一个对象不是强可达但可以通过遍历软引用到达，则该对象是软可达的。
- 如果一个对象既不是强可达的也不是软可达的，但可以通过遍历弱引用到达，则该对象是弱可达的。当对弱可达对象的弱引用被清除时，该对象就有资格进行终结。
- 如果一个对象既不是强可达、软可达也不是弱可达，则它是*虚可达*的，它已经完成，并且有一些虚引用引用它。
- 当一个对象无法通过上述任何一种方式到达时，它就是不可达的，因此可以回收。

每个引用对象类型都封装了对特定对象的单个引用，称为引用对象。引用对象提供了清除引用对象的方法。

以下是引用对象实例最常见的用途：

- 如果系统需要释放内存（例如：可以在需要时重新生成的缓存值），则保持对对象的访问，同时仍允许对其进行垃圾收集。
- 确定并可能在对象达到特定可达性级别时采取一些措施（结合 `java.lang.ref.ReferenceQueue` 类）。

### 显式垃圾收集

应用程序与垃圾回收交互的另一种方式是使用 `System.gc()` 显式调用完整垃圾回收。

这可能会在不必要时强制执行Major GC（例如，当Minor GC足够时），因此通常应该避免。显式垃圾收集的性能影响可以通过使用标志 `-XX:+DisableExplicitGC` 禁用它们来衡量，这会导致 VM 忽略对 `System.gc()` 的调用。

显式垃圾回收最常见的用途之一是远程方法调用 (RMI) 的分布式垃圾回收 (DGC)。使用 RMI 的应用程序引用其他虚拟机中的对象。如果不偶尔调用本地堆的垃圾收集，就无法在这些分布式应用程序中收集垃圾，因此 RMI 会定期强制执行Full GC。可以使用属性控制这些集合的频率，如下例所示：

```shell
java -Dsun.rmi.dgc.client.gcInterval=3600000
    -Dsun.rmi.dgc.server.gcInterval=3600000 ...
```

此示例指定每小时一次显式垃圾回收，而不是每分钟一次的默认速率。但是，这也可能导致某些对象需要更长的时间才能被回收。如果不需要 DGC 活动的及时性上限，这些属性可以设置为与 Long.MAX_VALUE 一样高，以使显式回收之间的时间无限地有效。

### 软引用

与客户端相比，软引用在服务器虚拟机中的存活时间更长。

可以使用命令行选项 `-XX:SoftRefLRUPolicyMSPerMB=<N>` 来控制清除速率，它指定每兆字节软引用将保持活动状态（一旦它不再强可达）的毫秒数 (ms)堆中的可用空间。默认值为每兆字节 1000 毫秒，这意味着对于堆中每兆字节的可用空间，软引用将存活（在回收到对象的最后一个强引用之后）1 秒。这是一个近似值，因为软引用仅在垃圾收集期间被清除，这可能偶尔会发生。

### 类元数据

Java 类在 Java Hotspot VM 中有一个内部表示，被称为类元数据。

在以前的 Java Hotspot VM 版本中，类元数据在所谓的永久代中分配。从 JDK 8 开始，永久代被移除，类元数据分配在本机内存中。默认情况下，可用于类元数据的本机内存量是无限的。使用选项 `-XX:MaxMetaspaceSize` 对用于类元数据的本机内存量设置上限。

Java Hotspot VM 显式管理用于元数据的空间。空间从操作系统请求，然后分成块。类加载器从其块中为元数据分配空间（块绑定到特定的类加载器）。当为类加载器卸载类时，它的块将被回收以供重用或返回给操作系统。元数据使用由 `mmap` 而非 `malloc` 分配的空间。

如果打开 `-XX:UseCompressedOops` 并使用 `-XX:UseCompressedClassesPointers`，那么本机内存的两个逻辑上不同的区域将用于类元数据。`-XX:UseCompressedClassPointers` 使用 32 位偏移来表示 64 位进程中的类指针，就像 `-XX:UseCompressedOops` 用于 Java 对象引用一样。区域的大小可以使用 `-XX:CompressedClassSpaceSize` 设置，默认为 1 GB。压缩类指针的空间保留为初始化时由 `-XX:mmap` 分配的空间，并根据需要提交。`-XX:MaxMetaspaceSize` 适用于提交的压缩类空间与其他类元数据空间的总和。

当相应的 Java 类被卸载时，类元数据被释放。Java 类作为垃圾回收的结果被卸载，并且垃圾回收可能被诱导卸载类和释放类元数据。当为类元数据提交的空间达到一定水平（高内存占用）时，将引发垃圾回收。垃圾回收后，高内存占用可能会根据从类元数据中释放的空间量而升高或降低。将提高内存占用，以免过早引发另一次垃圾回收。内存占用最初设置为命令行选项 `-XX:MetaspaceSize` 的值。它根据选项 `-XX:MaxMetaspaceFreeRatio` 和 `-XX:MinMetaspaceFreeRatio` 升高或降低。如果可用于类元数据的提交空间占类元数据的总提交空间的百分比大于 `-XX:MaxMetaspaceFreeRatio`，则将降低内存占用。如果它小于 `-XX:MinMetaspaceFreeRatio`，那么将提高内存占用。

为选项 `-XX:MetaspaceSize` 指定一个更高的值，以避免为类元数据引入早期垃圾回收。为应用程序分配的类元数据量取决于应用程序，并且不存在选择 `-XX:MetaspaceSize` 的一般准则。`-XX:MetaspaceSize` 的默认大小取决于平台，范围从 12 MB 到大约 20 MB。

有关用于元数据的空间的信息包含在堆的打印输出中。以下是典型的输出：

```log
[0,296s][info][gc,heap,exit] Heap
[0,296s][info][gc,heap,exit] garbage-first heap total 514048K, used 0K [0x00000005ca600000, 0x00000005ca8007d8, 0x00000007c0000000)
[0,296s][info][gc,heap,exit] region size 2048K, 1 young (2048K), 0 survivors (0K)
[0,296s][info][gc,heap,exit] Metaspace used 2575K, capacity 4480K, committed 4480K, reserved 1056768K
[0,296s][info][gc,heap,exit] class space used 238K, capacity 384K, committed 384K, reserved 1048576K
```

在以`Metaspace`开头的行中，使用的值是用于加载类的空间量。`capacity`是当前分配的块中可用于元数据的空间。承诺值是可用于块的空间量。`committed`是为元数据保留（但不一定提交）的空间量。以 `class space` 开头的行包含压缩类指针的元数据的相应值。

## 参考文献

官方文档：[HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/11/gctuning/index.html)
